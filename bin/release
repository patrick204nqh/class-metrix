#!/usr/bin/env ruby
# frozen_string_literal: true

require "optparse"
require_relative "../lib/class_metrix/version"

class ReleaseManager
  VALID_TYPES = %w[major minor patch].freeze

  def initialize
    @options = {
      type: "patch",
      push: false,
      dry_run: false
    }
  end

  def run(args)
    parse_options(args)

    puts "üß™ DRY RUN MODE - No changes will be made" if @options[:dry_run]

    current_version = ClassMetrix::VERSION
    new_version = calculate_new_version(current_version, @options[:type])

    puts "üì¶ Current version: #{current_version}"
    puts "üöÄ New version:     #{new_version}"

    unless @options[:dry_run]
      update_version_file(new_version)
      update_changelog(new_version)

      if @options[:push]
        create_and_push_tag(new_version)
      else
        puts "\nüè∑Ô∏è  To create and push the release tag, run:"
        puts "   git add -A && git commit -m 'Release v#{new_version}' && git tag v#{new_version} && git push origin master && git push origin v#{new_version}"
      end
    end

    puts "\n‚úÖ Release preparation complete!"
    puts "\nNext steps:"
    puts "1. Review CHANGELOG.md"
    puts "2. Commit and push changes"
    puts "3. Create and push tag (v#{new_version})"
    puts "4. GitHub Actions will automatically publish to RubyGems"
  end

  private

  def parse_options(args)
    OptionParser.new do |opts|
      opts.banner = "Usage: #{$0} [options]"

      opts.on("-t", "--type TYPE", VALID_TYPES,
              "Release type: #{VALID_TYPES.join(", ")} (default: patch)") do |type|
        @options[:type] = type
      end

      opts.on("-p", "--push", "Automatically commit, tag, and push") do
        @options[:push] = true
      end

      opts.on("-n", "--dry-run", "Show what would be done without making changes") do
        @options[:dry_run] = true
      end

      opts.on("-h", "--help", "Show this help") do
        puts opts
        exit
      end
    end.parse!(args)
  end

  def calculate_new_version(version, type)
    major, minor, patch = version.split(".").map(&:to_i)

    case type
    when "major"
      "#{major + 1}.0.0"
    when "minor"
      "#{major}.#{minor + 1}.0"
    when "patch"
      "#{major}.#{minor}.#{patch + 1}"
    end
  end

  def update_version_file(new_version)
    version_file = "lib/class_metrix/version.rb"
    content = File.read(version_file)
    updated_content = content.gsub(/VERSION = "[^"]*"/, "VERSION = \"#{new_version}\"")

    File.write(version_file, updated_content)
    puts "üìù Updated #{version_file}"
  end

  def update_changelog(new_version)
    changelog_file = "CHANGELOG.md"
    return unless File.exist?(changelog_file)

    content = File.read(changelog_file)
    today = Time.now.strftime("%Y-%m-%d")

    # Replace [Unreleased] with the new version
    updated_content = content.gsub(
      /## \[Unreleased\]/,
      "## [Unreleased]\n\n## [#{new_version}] - #{today}"
    )

    File.write(changelog_file, updated_content)
    puts "üìù Updated #{changelog_file}"
  end

  def create_and_push_tag(new_version)
    puts "\nüè∑Ô∏è  Creating and pushing tag..."

    system("git add -A")
    system("git commit -m 'Release v#{new_version}'")
    system("git tag v#{new_version}")
    system("git push origin master")
    system("git push origin v#{new_version}")

    puts "‚úÖ Tag v#{new_version} created and pushed"
  end
end

ReleaseManager.new.run(ARGV) if __FILE__ == $0
