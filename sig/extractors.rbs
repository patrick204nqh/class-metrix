# Specialized extractor classes
module ClassMetrix
  module Extractors
    class ConstantsExtractor
    @classes: Array[Class]
    @filters: Array[Regexp | String]
    @handle_errors: bool
    @options: Hash[Symbol, untyped]
    @debug_level: Symbol
    @logger: ClassMetrix::Utils::DebugLogger

    def initialize: (Array[Class] classes, Array[Regexp | String] filters, bool handle_errors, ?Hash[Symbol, untyped] options) -> void
    def extract: () -> Hash[Symbol, untyped]

    private

    def default_options: () -> Hash[Symbol, untyped]
    def build_headers: () -> Array[String]
    def build_rows: (Array[String] constant_names) -> Array[Array[untyped]]
    def get_all_constant_names: () -> Array[String]
    def inheritance_or_modules_enabled?: () -> bool
    def get_comprehensive_constants: (Class klass) -> Array[Symbol]
    def get_inherited_constants: (Class klass) -> Set[Symbol]
    def get_module_constants: (Class klass) -> Set[Symbol]
    def get_all_included_modules: (Class klass) -> Array[Module]
    def core_class?: (untyped klass) -> bool
    def apply_filters: (Array[String] constant_names) -> Array[String]
    def extract_constant_value: (Class klass, String const_name) -> untyped
    def find_constant_source: (Class klass, String const_name) -> Hash[Symbol, untyped]?
    def find_inherited_constant: (Class klass, String const_name) -> Hash[Symbol, untyped]?
    def find_module_constant: (Class klass, String const_name) -> Hash[Symbol, untyped]?
    def build_constant_info: (untyped value, String source, Symbol type) -> Hash[Symbol, untyped]
    def debug_log: (String message) -> void
    end

    class MethodsExtractor
    @classes: Array[Class]
    @filters: Array[Regexp | String]
    @handle_errors: bool
    @options: Hash[Symbol, untyped]
    @method_collection_service: Services::Collection::MethodCollectionService
    @method_filter_service: Services::Filtering::MethodFilterService
    @method_call_service: Services::MethodCallService

    def initialize: (Array[Class] classes, Array[Regexp | String] filters, bool handle_errors, ?Hash[Symbol, untyped] options) -> void
    def extract: () -> Hash[Symbol, untyped]

    private

    def empty_result: () -> Hash[Symbol, Array[untyped]]
    def collect_and_filter_methods: () -> Array[String]
    def default_options: () -> Hash[Symbol, untyped]
    def build_headers: () -> Array[String]
    def build_rows: (Array[String] method_names) -> Array[Array[untyped]]
    def build_row: (String method_name) -> Array[untyped]
  end

  module Services
    module Collection
      class MethodCollectionService
        @options: Hash[Symbol, untyped]

        def initialize: (?Hash[Symbol, untyped] options) -> void
        def collect_from_classes: (Array[Class] classes) -> Array[String]

        private

        def collect_from_single_class: (Class klass) -> Array[Symbol]
        def collect_comprehensive_methods: (Class klass) -> Array[Symbol]
        def inheritance_or_modules_enabled?: () -> bool
        def include_inherited?: () -> bool
        def include_modules?: () -> bool
      end

      class InheritanceCollector
        def collect: (Class klass) -> Set[Symbol]

        private

        def traverse_parent_chain: (Class klass) { (Class) -> void } -> void
        def core_class?: (Class klass) -> bool
      end

      class ModuleCollector
        EXCLUDED_METHODS: Array[String]

        def collect: (Class klass) -> Set[Symbol]

        private

        def collect_from_modules: (Class klass) -> Array[String]
        def get_relevant_modules: (Class klass) -> Array[Module]
        def extract_valid_methods: (Module mod) -> Array[String]
        def core_module?: (Module mod) -> bool
      end
    end

    module Filtering
      class MethodFilterService
        @filters: Array[Regexp | String]

        def initialize: (Array[Regexp | String]? filters) -> void
        def apply: (Array[String] method_names) -> Array[String]

        private

        def apply_single_filter: (Array[String] method_names, Regexp | String filter) -> Array[String]
        def matches_filter?: (String name, Regexp | String filter) -> bool
      end
    end

    module Resolution
      class MethodResolver
        @options: Hash[Symbol, untyped]

        def initialize: (?Hash[Symbol, untyped] options) -> void
        def resolve: (Class klass, String method_name) -> Hash[Symbol, untyped]?

        private

        def resolve_method_source: (Class klass, Symbol method_sym, String method_name) -> Hash[Symbol, untyped]?
        def own_method?: (Class klass, Symbol method_sym) -> bool
        def resolve_inherited_method: (Class klass, Symbol method_sym, String method_name) -> Hash[Symbol, untyped]?
        def resolve_module_method: (Class klass, Symbol method_sym, String method_name) -> Hash[Symbol, untyped]?
        def create_method_info: (String source, Symbol type, ?Proc? callable) -> Hash[Symbol, untyped]
      end

      class InheritedMethodResolver
        def resolve: (Class klass, Symbol method_sym, String method_name) -> Hash[Symbol, untyped]?

        private

        def traverse_parent_chain: (Class klass) { (Class) -> void } -> void
        def create_callable: (Class parent_class, String method_name) -> Proc
        def create_method_info: (String source, Symbol type, Proc callable) -> Hash[Symbol, untyped]
        def core_class?: (Class klass) -> bool
      end

      class ModuleMethodResolver
        @options: Hash[Symbol, untyped]

        def initialize: (?Hash[Symbol, untyped] options) -> void
        def resolve: (Class klass, Symbol method_sym, String method_name) -> Hash[Symbol, untyped]?

        private

        def process_module: (Class klass, Module mod, Symbol method_sym, String method_name) -> Hash[Symbol, untyped]?
        def get_singleton_modules: (Class klass) -> Array[Module]
        def create_callable: (Class klass, String method_name) -> Proc
        def determine_source: (Class klass, Module mod) -> String
        def create_method_info: (String source, Symbol type, Proc callable) -> Hash[Symbol, untyped]
        def core_module?: (Module mod) -> bool
      end
    end

    class MethodCallService
      @handle_errors: bool
      @options: Hash[Symbol, untyped]

      def initialize: (bool handle_errors, ?Hash[Symbol, untyped] options) -> void
      def call_method: (Class klass, String method_name) -> untyped

      private

      def execute_method: (Hash[Symbol, untyped] method_info, Class klass, String method_name) -> untyped
      def handle_missing_method: () -> untyped
      def handle_error: (StandardError error) -> untyped
    end
  end

  class MultiTypeExtractor
    @classes: Array[Class]
    @types: Array[Symbol]
    @filters: Array[Regexp | String]
    @modules: Array[Module]
    @handle_errors: bool
    @options: Hash[Symbol, untyped]

    def initialize: (Array[Class] classes, Array[Symbol] types, Array[Regexp | String] filters, ?Hash[Symbol, untyped] extraction_config) -> void
    def extract: () -> Hash[Symbol, untyped]

    private

    def extract_single_type: (Symbol type) -> Hash[Symbol, untyped]
    def type_label: (Symbol type) -> String
  end
  end
end
